{"version":3,"sources":["../../src/merge-props.ts"],"names":["callAllHandlers","cx","isFunction","isString","mergeProps","result","args","props","key","test","className","id","undefined"],"mappings":"AAAA,SAASA,eAAT,QAAgC,YAAhC;AACA,SAASC,EAAT,QAAmB,OAAnB;AACA,SAASC,UAAT,EAAqBC,QAArB,QAAqC,aAArC;AAgBA,OAAO,SAASC,UAAT,GAE+B;AACpC,MAAMC,MAAa,GAAG,EAAtB;;AADoC,oCADjCC,IACiC;AADjCA,IAAAA,IACiC;AAAA;;AAEpC,OAAK,IAAMC,KAAX,IAAoBD,IAApB,EAA0B;AACxB,SAAK,IAAME,KAAX,IAAkBH,MAAlB,EAA0B;AACxB;AACA,UACE,WAAWI,IAAX,CAAgBD,KAAhB,KACAN,UAAU,CAACG,MAAM,CAACG,KAAD,CAAP,CADV,IAEAN,UAAU,CAACK,KAAK,CAACC,KAAD,CAAN,CAHZ,EAIE;AACAH,QAAAA,MAAM,CAACG,KAAD,CAAN,GAAcR,eAAe,CAACK,MAAM,CAACG,KAAD,CAAP,EAAcD,KAAK,CAACC,KAAD,CAAnB,CAA7B,CADA,CAEA;AACD,OAPD,MAOO,IACLA,KAAG,KAAK,WAAR,IACAL,QAAQ,CAACE,MAAM,CAACK,SAAR,CADR,IAEAP,QAAQ,CAACI,KAAK,CAACG,SAAP,CAHH,EAIL;AACAL,QAAAA,MAAM,CAACG,KAAD,CAAN,GAAcP,EAAE,CAACI,MAAM,CAACK,SAAR,EAAmBH,KAAK,CAACG,SAAzB,CAAhB;AACD,OANM,MAMA,IAAIF,KAAG,KAAK,IAAR,IAAgBH,MAAM,CAACM,EAAvB,IAA6BJ,KAAK,CAACI,EAAvC,EAA2C;AAChDN,QAAAA,MAAM,CAACM,EAAP,GAAYV,EAAE,CAACI,MAAM,CAACM,EAAR,EAAYJ,KAAK,CAACI,EAAlB,CAAd,CADgD,CAEhD;AACD,OAHM,MAGA;AACLN,QAAAA,MAAM,CAACG,KAAD,CAAN,GAAcD,KAAK,CAACC,KAAD,CAAL,KAAeI,SAAf,GAA2BL,KAAK,CAACC,KAAD,CAAhC,GAAwCH,MAAM,CAACG,KAAD,CAA5D;AACD;AACF,KAtBuB,CAwBxB;;;AACA,SAAK,IAAMA,KAAX,IAAkBD,KAAlB,EAAyB;AACvB,UAAIF,MAAM,CAACG,KAAD,CAAN,KAAgBI,SAApB,EAA+B;AAC7BP,QAAAA,MAAM,CAACG,KAAD,CAAN,GAAcD,KAAK,CAACC,KAAD,CAAnB;AACD;AACF;AACF;;AAED,SAAOH,MAAP;AACD","sourcesContent":["import { callAllHandlers } from \"./function\"\nimport { cx } from \"./dom\"\nimport { isFunction, isString } from \"./assertion\"\n\ninterface Props {\n  [key: string]: any\n}\n\ntype TupleTypes<T> = { [P in keyof T]: T[P] } extends { [key: number]: infer V }\n  ? V\n  : never\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I,\n) => void\n  ? I\n  : never\n\nexport function mergeProps<T extends Props[]>(\n  ...args: T\n): UnionToIntersection<TupleTypes<T>> {\n  const result: Props = {}\n  for (const props of args) {\n    for (const key in result) {\n      // Chain events\n      if (\n        /^on[A-Z]/.test(key) &&\n        isFunction(result[key]) &&\n        isFunction(props[key])\n      ) {\n        result[key] = callAllHandlers(result[key], props[key])\n        // Merge classnames, sometimes classNames are empty string which eval to false, so we just need to do a type check\n      } else if (\n        key === \"className\" &&\n        isString(result.className) &&\n        isString(props.className)\n      ) {\n        result[key] = cx(result.className, props.className)\n      } else if (key === \"id\" && result.id && props.id) {\n        result.id = cx(result.id, props.id)\n        // Override others\n      } else {\n        result[key] = props[key] !== undefined ? props[key] : result[key]\n      }\n    }\n\n    // Add props from b that are not in a\n    for (const key in props) {\n      if (result[key] === undefined) {\n        result[key] = props[key]\n      }\n    }\n  }\n\n  return result as UnionToIntersection<TupleTypes<T>>\n}\n"],"file":"merge-props.js"}