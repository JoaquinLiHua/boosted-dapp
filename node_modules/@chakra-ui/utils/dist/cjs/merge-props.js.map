{"version":3,"sources":["../../src/merge-props.ts"],"names":["mergeProps","result","args","props","key","test","className","id","undefined"],"mappings":";;;;;AAAA;;AACA;;AACA;;AAgBO,SAASA,UAAT,GAE+B;AACpC,MAAMC,MAAa,GAAG,EAAtB;;AADoC,oCADjCC,IACiC;AADjCA,IAAAA,IACiC;AAAA;;AAEpC,2BAAoBA,IAApB,2BAA0B;AAArB,QAAMC,KAAK,YAAX;;AACH,SAAK,IAAMC,KAAX,IAAkBH,MAAlB,EAA0B;AACxB;AACA,UACE,WAAWI,IAAX,CAAgBD,KAAhB,KACA,2BAAWH,MAAM,CAACG,KAAD,CAAjB,CADA,IAEA,2BAAWD,KAAK,CAACC,KAAD,CAAhB,CAHF,EAIE;AACAH,QAAAA,MAAM,CAACG,KAAD,CAAN,GAAc,+BAAgBH,MAAM,CAACG,KAAD,CAAtB,EAA6BD,KAAK,CAACC,KAAD,CAAlC,CAAd,CADA,CAEA;AACD,OAPD,MAOO,IACLA,KAAG,KAAK,WAAR,IACA,yBAASH,MAAM,CAACK,SAAhB,CADA,IAEA,yBAASH,KAAK,CAACG,SAAf,CAHK,EAIL;AACAL,QAAAA,MAAM,CAACG,KAAD,CAAN,GAAc,aAAGH,MAAM,CAACK,SAAV,EAAqBH,KAAK,CAACG,SAA3B,CAAd;AACD,OANM,MAMA,IAAIF,KAAG,KAAK,IAAR,IAAgBH,MAAM,CAACM,EAAvB,IAA6BJ,KAAK,CAACI,EAAvC,EAA2C;AAChDN,QAAAA,MAAM,CAACM,EAAP,GAAY,aAAGN,MAAM,CAACM,EAAV,EAAcJ,KAAK,CAACI,EAApB,CAAZ,CADgD,CAEhD;AACD,OAHM,MAGA;AACLN,QAAAA,MAAM,CAACG,KAAD,CAAN,GAAcD,KAAK,CAACC,KAAD,CAAL,KAAeI,SAAf,GAA2BL,KAAK,CAACC,KAAD,CAAhC,GAAwCH,MAAM,CAACG,KAAD,CAA5D;AACD;AACF,KAtBuB,CAwBxB;;;AACA,SAAK,IAAMA,KAAX,IAAkBD,KAAlB,EAAyB;AACvB,UAAIF,MAAM,CAACG,KAAD,CAAN,KAAgBI,SAApB,EAA+B;AAC7BP,QAAAA,MAAM,CAACG,KAAD,CAAN,GAAcD,KAAK,CAACC,KAAD,CAAnB;AACD;AACF;AACF;;AAED,SAAOH,MAAP;AACD","sourcesContent":["import { callAllHandlers } from \"./function\"\nimport { cx } from \"./dom\"\nimport { isFunction, isString } from \"./assertion\"\n\ninterface Props {\n  [key: string]: any\n}\n\ntype TupleTypes<T> = { [P in keyof T]: T[P] } extends { [key: number]: infer V }\n  ? V\n  : never\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I,\n) => void\n  ? I\n  : never\n\nexport function mergeProps<T extends Props[]>(\n  ...args: T\n): UnionToIntersection<TupleTypes<T>> {\n  const result: Props = {}\n  for (const props of args) {\n    for (const key in result) {\n      // Chain events\n      if (\n        /^on[A-Z]/.test(key) &&\n        isFunction(result[key]) &&\n        isFunction(props[key])\n      ) {\n        result[key] = callAllHandlers(result[key], props[key])\n        // Merge classnames, sometimes classNames are empty string which eval to false, so we just need to do a type check\n      } else if (\n        key === \"className\" &&\n        isString(result.className) &&\n        isString(props.className)\n      ) {\n        result[key] = cx(result.className, props.className)\n      } else if (key === \"id\" && result.id && props.id) {\n        result.id = cx(result.id, props.id)\n        // Override others\n      } else {\n        result[key] = props[key] !== undefined ? props[key] : result[key]\n      }\n    }\n\n    // Add props from b that are not in a\n    for (const key in props) {\n      if (result[key] === undefined) {\n        result[key] = props[key]\n      }\n    }\n  }\n\n  return result as UnionToIntersection<TupleTypes<T>>\n}\n"],"file":"merge-props.js"}