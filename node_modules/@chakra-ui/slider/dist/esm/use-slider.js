function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import { useBoolean, useControllableState, useDimensions, useEventCallback, useEventListener, useIds, useUpdateEffect } from "@chakra-ui/hooks";
import { ariaAttr, callAllHandlers, clampValue, createOnKeyDown, dataAttr, focus, getBox, getOwnerDocument, mergeRefs, percentToValue, roundValueToStep, valueToPercent, isRightClick } from "@chakra-ui/utils";
import { useState, useRef, useCallback, useMemo, useEffect } from "react";

/**
 * React hook that implements an accessible range slider.
 *
 * It's an alternative to `<input type="range" />`, and returns
 * prop getters for the component parts
 *
 * @see Docs     https://chakra-ui.com/components/slider
 * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.1/#slider
 */
export function useSlider(props) {
  var _getAriaValueText, _thumbBoxModel$border;

  var {
    min = 0,
    max = 100,
    onChange,
    value: valueProp,
    defaultValue,
    isReversed,
    orientation,
    id: idProp,
    isDisabled,
    isReadOnly,
    onChangeStart,
    onChangeEnd,
    step = 1,
    getAriaValueText,
    "aria-valuetext": ariaValueText,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    name
  } = props,
      htmlProps = _objectWithoutPropertiesLoose(props, ["min", "max", "onChange", "value", "defaultValue", "isReversed", "orientation", "id", "isDisabled", "isReadOnly", "onChangeStart", "onChangeEnd", "step", "getAriaValueText", "aria-valuetext", "aria-label", "aria-labelledby", "name"]);

  var [isDragging, setDragging] = useBoolean();
  var [isFocused, setFocused] = useBoolean();
  var [eventSource, setEventSource] = useState();
  var isInteractive = !(isDisabled || isReadOnly);
  /**
   * Enable the slider handle controlled and uncontrolled scenarios
   */

  var [computedValue, setValue] = useControllableState({
    value: valueProp,
    defaultValue: defaultValue != null ? defaultValue : getDefaultValue(min, max),
    onChange,
    shouldUpdate: (prev, next) => prev !== next
  });
  /**
   * Slider uses DOM APIs to add and remove event listeners.
   * Noticed some issues with React's synthetic events.
   *
   * We use `ref` to save the functions used to remove
   * the event listeners.
   *
   * Ideally, we'll love to use pointer-events API but it's
   * not fully supported in all browsers.
   */

  var cleanUpRef = useRef({});
  /**
   * Constrain the value because it can't be less than min
   * or greater than max
   */

  var value = clampValue(computedValue, min, max);
  var prev = useRef();
  var reversedValue = max - value + min;
  var trackValue = isReversed ? reversedValue : value;
  var trackPercent = valueToPercent(trackValue, min, max);
  var isVertical = orientation === "vertical";
  /**
   * Let's keep a reference to the slider track and thumb
   */

  var trackRef = useRef(null);
  var thumbRef = useRef(null);
  var rootRef = useRef(null);
  /**
   * Generate unique ids for component parts
   */

  var [thumbId, trackId] = useIds(idProp, "slider-thumb", "slider-track");
  /**
   * Get relative value of slider from the event by tracking
   * how far you clicked within the track to determine the value
   */

  var getValueFromPointer = useCallback(event => {
    var _event$touches$, _event$touches;

    if (!trackRef.current) return;
    var trackRect = getBox(trackRef.current).borderBox;
    var {
      clientX,
      clientY
    } = (_event$touches$ = (_event$touches = event.touches) == null ? void 0 : _event$touches[0]) != null ? _event$touches$ : event;
    var diff = isVertical ? trackRect.bottom - clientY : clientX - trackRect.left;
    var length = isVertical ? trackRect.height : trackRect.width;
    var percent = diff / length;

    if (isReversed) {
      percent = 1 - percent;
    }

    var nextValue = percentToValue(percent, min, max);

    if (step) {
      nextValue = parseFloat(roundValueToStep(nextValue, min, step));
    }

    nextValue = clampValue(nextValue, min, max);
    return nextValue;
  }, [isVertical, isReversed, max, min, step]);
  var tenSteps = (max - min) / 10;
  var oneStep = step || (max - min) / 100;
  var constrain = useCallback(value => {
    // bail out if slider isn't interactive
    if (!isInteractive) return;
    prev.current = value;
    value = parseFloat(roundValueToStep(value, min, oneStep));
    value = clampValue(value, min, max);
    setValue(value);
  }, [oneStep, max, min, setValue, isInteractive]);
  var actions = useMemo(() => ({
    stepUp: function stepUp(step) {
      if (step === void 0) {
        step = oneStep;
      }

      var next = isReversed ? value - step : value + step;
      constrain(next);
    },
    stepDown: function stepDown(step) {
      if (step === void 0) {
        step = oneStep;
      }

      var next = isReversed ? value + step : value - step;
      constrain(next);
    },
    reset: () => constrain(defaultValue || 0),
    stepTo: value => constrain(value)
  }), [constrain, isReversed, value, oneStep, defaultValue]);
  /**
   * Keyboard interaction to ensure users can operate
   * the slider using only their keyboard.
   */

  var onKeyDown = createOnKeyDown({
    stopPropagation: true,
    onKey: () => setEventSource("keyboard"),
    keyMap: {
      ArrowRight: () => actions.stepUp(),
      ArrowUp: () => actions.stepUp(),
      ArrowLeft: () => actions.stepDown(),
      ArrowDown: () => actions.stepDown(),
      PageUp: () => actions.stepUp(tenSteps),
      PageDown: () => actions.stepDown(tenSteps),
      Home: () => constrain(min),
      End: () => constrain(max)
    }
  });
  /**
   * ARIA (Optional): To define a human readable representation of the value,
   * we allow users pass aria-valuetext.
   */

  var valueText = (_getAriaValueText = getAriaValueText == null ? void 0 : getAriaValueText(value)) != null ? _getAriaValueText : ariaValueText;
  /**
   * Measure the dimensions of the thumb so
   * we can center it within the track properly
   */

  var thumbBoxModel = useDimensions(thumbRef);
  var thumbRect = (_thumbBoxModel$border = thumbBoxModel == null ? void 0 : thumbBoxModel.borderBox) != null ? _thumbBoxModel$border : {
    width: 0,
    height: 0
  };
  /**
   * Compute styles for all component parts.
   */

  var thumbStyle = _extends({
    position: "absolute",
    userSelect: "none",
    touchAction: "none"
  }, orient({
    orientation,
    vertical: {
      bottom: "calc(" + trackPercent + "% - " + thumbRect.height / 2 + "px)"
    },
    horizontal: {
      left: "calc(" + trackPercent + "% - " + thumbRect.width / 2 + "px)"
    }
  }));

  var rootStyle = _extends({
    position: "relative",
    touchAction: "none",
    WebkitTapHighlightColor: "rgba(0,0,0,0)",
    userSelect: "none",
    outline: 0
  }, orient({
    orientation,
    vertical: {
      paddingLeft: thumbRect.width / 2,
      paddingRight: thumbRect.width / 2
    },
    horizontal: {
      paddingTop: thumbRect.height / 2,
      paddingBottom: thumbRect.height / 2
    }
  }));

  var trackStyle = _extends({
    position: "absolute"
  }, orient({
    orientation,
    vertical: {
      left: "50%",
      transform: "translateX(-50%)",
      height: "100%"
    },
    horizontal: {
      top: "50%",
      transform: "translateY(-50%)",
      width: "100%"
    }
  }));

  var innerTrackStyle = _extends({}, trackStyle, orient({
    orientation,
    vertical: isReversed ? {
      height: 100 - trackPercent + "%",
      top: 0
    } : {
      height: trackPercent + "%",
      bottom: 0
    },
    horizontal: isReversed ? {
      width: 100 - trackPercent + "%",
      right: 0
    } : {
      width: trackPercent + "%",
      left: 0
    }
  }));

  useUpdateEffect(() => {
    if (thumbRef.current) {
      focus(thumbRef.current);
    }
  }, [value]);
  useUpdateEffect(() => {
    var shouldUpdate = !isDragging && eventSource !== "keyboard" && prev.current !== value;

    if (shouldUpdate) {
      onChangeEnd == null ? void 0 : onChangeEnd(value);
    }

    if (eventSource === "keyboard") {
      onChangeEnd == null ? void 0 : onChangeEnd(value);
    }
  }, [isDragging, onChangeEnd, value, eventSource]);
  var onMouseDown = useEventCallback(event => {
    /**
     * Prevent update if it's right-click
     */
    if (isRightClick(event)) return;
    if (!isInteractive || !rootRef.current) return;
    setDragging.on();
    prev.current = value;
    onChangeStart == null ? void 0 : onChangeStart(value);
    var doc = getOwnerDocument(rootRef.current);

    var run = event => {
      var nextValue = getValueFromPointer(event);

      if (nextValue != null && nextValue !== value) {
        setEventSource("mouse");
        setValue(nextValue);
      }
    };

    run(event);
    doc.addEventListener("mousemove", run);

    var clean = () => {
      doc.removeEventListener("mousemove", run);
      setDragging.off();
    };

    doc.addEventListener("mouseup", clean);

    cleanUpRef.current.mouseup = () => {
      doc.removeEventListener("mouseup", clean);
    };
  });
  var onTouchStart = useEventCallback(event => {
    if (!isInteractive || !rootRef.current) return; // Prevent scrolling for touch events

    event.preventDefault();
    setDragging.on();
    prev.current = value;
    onChangeStart == null ? void 0 : onChangeStart(value);
    var doc = getOwnerDocument(rootRef.current);

    var run = event => {
      var nextValue = getValueFromPointer(event);

      if (nextValue != null && nextValue !== value) {
        setEventSource("touch");
        setValue(nextValue);
      }
    };

    run(event);
    doc.addEventListener("touchmove", run);

    var clean = () => {
      doc.removeEventListener("touchmove", run);
      setDragging.off();
    };

    doc.addEventListener("touchend", clean);
    doc.addEventListener("touchcancel", clean);

    cleanUpRef.current.touchend = () => {
      doc.removeEventListener("touchend", clean);
    };

    cleanUpRef.current.touchcancel = () => {
      doc.removeEventListener("touchcancel", clean);
    };
  });
  /**
   * Remove all event handlers
   */

  var detach = () => {
    Object.values(cleanUpRef.current).forEach(cleanup => {
      cleanup == null ? void 0 : cleanup();
    });
    cleanUpRef.current = {};
  };
  /**
   * Ensure we clean up listeners when slider unmounts
   */


  useEffect(() => {
    return () => detach();
  }, []);
  useUpdateEffect(() => {
    if (!isDragging) {
      detach();
    }
  }, [isDragging]);
  cleanUpRef.current.mousedown = useEventListener("mousedown", onMouseDown, rootRef.current);
  cleanUpRef.current.touchstart = useEventListener("touchstart", onTouchStart, rootRef.current);
  return {
    state: {
      value,
      isFocused,
      isDragging: isDragging
    },
    actions,
    getRootProps: function getRootProps(props, ref) {
      if (props === void 0) {
        props = {};
      }

      if (ref === void 0) {
        ref = null;
      }

      return _extends({}, props, htmlProps, {
        ref: mergeRefs(ref, rootRef),
        tabIndex: -1,
        "aria-disabled": ariaAttr(isDisabled),
        "data-focused": dataAttr(isFocused),
        style: _extends({}, props.style, rootStyle)
      });
    },
    getTrackProps: function getTrackProps(props, ref) {
      if (props === void 0) {
        props = {};
      }

      if (ref === void 0) {
        ref = null;
      }

      return _extends({}, props, {
        ref: mergeRefs(ref, trackRef),
        id: trackId,
        "data-disabled": dataAttr(isDisabled),
        style: _extends({}, props.style, trackStyle)
      });
    },
    getInnerTrackProps: function getInnerTrackProps(props, ref) {
      if (props === void 0) {
        props = {};
      }

      if (ref === void 0) {
        ref = null;
      }

      return _extends({}, props, {
        ref,
        style: _extends({}, props.style, innerTrackStyle)
      });
    },
    getThumbProps: function getThumbProps(props, ref) {
      if (props === void 0) {
        props = {};
      }

      if (ref === void 0) {
        ref = null;
      }

      return _extends({}, props, {
        ref: mergeRefs(ref, thumbRef),
        role: "slider",
        tabIndex: 0,
        id: thumbId,
        "data-active": dataAttr(isDragging),
        "aria-valuetext": valueText,
        "aria-valuemin": min,
        "aria-valuemax": max,
        "aria-valuenow": value,
        "aria-orientation": orientation,
        "aria-disabled": ariaAttr(isDisabled),
        "aria-readonly": ariaAttr(isReadOnly),
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabel ? undefined : ariaLabelledBy,
        style: _extends({}, props.style, thumbStyle),
        onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),
        onFocus: callAllHandlers(props.onFocus, setFocused.on),
        onBlur: callAllHandlers(props.onBlur, setFocused.off)
      });
    },
    getMarkerProps: function getMarkerProps(props, ref) {
      if (props === void 0) {
        props = {};
      }

      if (ref === void 0) {
        ref = null;
      }

      var isInRange = !(props.value < min || props.value > max);
      var isHighlighted = value >= props.value;
      var markerPercent = valueToPercent(props.value, min, max);

      var markerStyle = _extends({
        position: "absolute",
        pointerEvents: "none"
      }, orient({
        orientation,
        vertical: {
          bottom: isReversed ? 100 - markerPercent + "%" : markerPercent + "%"
        },
        horizontal: {
          left: isReversed ? 100 - markerPercent + "%" : markerPercent + "%"
        }
      }));

      return _extends({}, props, {
        ref,
        role: "presentation",
        "aria-hidden": true,
        "data-disabled": dataAttr(isDisabled),
        "data-invalid": dataAttr(!isInRange),
        "data-highlighted": dataAttr(isHighlighted),
        style: _extends({}, props.style, markerStyle)
      });
    },
    getInputProps: function getInputProps(props, ref) {
      if (props === void 0) {
        props = {};
      }

      return _extends({}, props, {
        ref,
        type: "hidden",
        value,
        name
      });
    }
  };
}

function orient(options) {
  var {
    orientation,
    vertical,
    horizontal
  } = options;
  return orientation === "vertical" ? vertical : horizontal;
}
/**
 * The browser <input type="range" /> calculates
 * the default value of a slider by using mid-point
 * between the min and the max.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range
 */


function getDefaultValue(min, max) {
  return max < min ? min : min + (max - min) / 2;
}
//# sourceMappingURL=use-slider.js.map