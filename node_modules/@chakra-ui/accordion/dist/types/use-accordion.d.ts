import { Dict } from "@chakra-ui/utils";
import { Ref, ReactNode } from "react";
export declare type ExpandedIndex = number | number[];
export interface UseAccordionProps {
    /**
     * If `true`, multiple accordion items can be expanded at once.
     */
    allowMultiple?: boolean;
    /**
     * If `true`, any expanded accordion item can be collapsed again.
     */
    allowToggle?: boolean;
    /**
     * The index(es) of the expanded accordion item
     */
    index?: ExpandedIndex;
    /**
     * The initial index(es) of the expanded accordion item
     */
    defaultIndex?: ExpandedIndex;
    /**
     * The callback invoked when accordion items are expanded or collapsed.
     */
    onChange?: (expandedIndex: ExpandedIndex) => void;
    /**
     * The content of the accordion. Must be `AccordionItem`
     */
    children: ReactNode;
}
/**
 * useAccordion hook provides all the state and focus management logic
 * for accordion items.
 */
export declare function useAccordion(props: UseAccordionProps): {
    children: import("react").ReactElement<any, string | ((props: any) => import("react").ReactElement<any, string | any | (new (props: any) => import("react").Component<any, any, any>)> | null) | (new (props: any) => import("react").Component<any, any, any>)>[];
    htmlProps: {};
    focusedIndex: number;
    setFocusedIndex: import("react").Dispatch<import("react").SetStateAction<number>>;
    domContext: {
        descendants: {
            element: HTMLElement | null;
            index?: number | undefined;
            disabled?: boolean | undefined;
            focusable?: boolean | undefined;
        }[];
        register: ({ element, ...rest }: {
            element: HTMLElement | null;
            index?: number | undefined;
            disabled?: boolean | undefined;
            focusable?: boolean | undefined;
        }) => void;
        unregister: (element: HTMLElement) => void;
    };
};
export declare type UseAccordionReturn = ReturnType<typeof useAccordion>;
declare type AccordionContext = Omit<UseAccordionReturn, "children" | "htmlProps"> & {
    reduceMotion: boolean;
};
declare const AccordionProvider: import("react").Provider<AccordionContext>, useAccordionContext: () => AccordionContext;
export { AccordionProvider, useAccordionContext };
export interface UseAccordionItemProps {
    /**
     * If `true`, expands the accordion in the controlled mode.
     */
    isOpen?: boolean;
    /**
     * If `true`, the accordion item will be disabled.
     */
    isDisabled?: boolean;
    /**
     * If `true`, the accordion item will be focusable.
     */
    isFocusable?: boolean;
    /**
     * A unique id for the accordion item.
     */
    id?: string;
    /**
     * The callback fired when the accordion is expanded/collapsed.
     */
    onChange?: (isOpen: boolean) => void;
}
/**
 * useAccordionItem
 *
 * React hook that provides the open/close functionality
 * for an accordion item and it's children
 */
export declare function useAccordionItem(props: UseAccordionItemProps): {
    isOpen: boolean | undefined;
    isDisabled: boolean | undefined;
    isFocusable: boolean | undefined;
    onOpen: () => void;
    onClose: () => void;
    getButtonProps: (props?: Dict, ref?: Ref<any>) => {
        ref: (value: any) => void;
        id: string;
        disabled: boolean;
        "aria-expanded": boolean;
        "aria-controls": string;
        onClick: (event: unknown) => void;
        onFocus: (event: unknown) => void;
        onKeyDown: (event: unknown) => void;
    };
    getPanelProps: (props?: Dict, ref?: Ref<any>) => {
        ref: Ref<any>;
        role: string;
        id: string;
        "aria-labelledby": string;
        hidden: boolean;
    };
    htmlProps: {};
};
export declare type UseAccordionItemReturn = ReturnType<typeof useAccordionItem>;
