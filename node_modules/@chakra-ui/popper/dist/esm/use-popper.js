function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import * as React from "react";
import { createPopper } from "@popperjs/core";
import { getArrowStyles, toTransformOrigin } from "./popper.utils";
var isBrowser = typeof window !== "undefined";
var useSafeLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect;
export function usePopper(props) {
  var {
    placement: initialPlacement = "bottom",
    offset: offsetProp,
    preventOverflow = true,
    fixed = false,
    forceUpdate = true,
    flip = true,
    arrowSize = 10,
    arrowShadowColor,
    gutter = arrowSize,
    eventsEnabled = true,
    modifiers
  } = props;
  var popper = React.useRef(null);
  var referenceRef = React.useRef(null);
  var popoverRef = React.useRef(null);
  var arrowRef = React.useRef(null);
  var [originalPlacement, place] = React.useState(initialPlacement);
  var [placement, setPlacement] = React.useState(initialPlacement);
  var [offset] = React.useState(offsetProp || [0, gutter]);
  var [popoverStyles, setPopoverStyles] = React.useState({});
  var [arrowStyles, setArrowStyles] = React.useState({});
  var update = React.useCallback(() => {
    if (popper.current) {
      popper.current.forceUpdate();
      return true;
    }

    return false;
  }, []);
  var modifiersOverride = modifiers != null ? modifiers : [];
  useSafeLayoutEffect(() => {
    if (referenceRef.current && popoverRef.current) {
      popper.current = createPopper(referenceRef.current, popoverRef.current, {
        placement: originalPlacement,
        strategy: fixed ? "fixed" : "absolute",
        modifiers: [{
          name: "eventListeners",
          enabled: eventsEnabled
        }, {
          name: "applyStyles",
          enabled: false
        }, {
          name: "flip",
          enabled: flip,
          options: {
            padding: 8
          }
        }, {
          name: "computeStyles",
          options: {
            gpuAcceleration: false,
            adaptive: false
          }
        }, {
          name: "offset",
          options: {
            offset
          }
        }, {
          name: "preventOverflow",
          enabled: preventOverflow,
          options: {
            tetherOffset: () => {
              var _arrowRef$current;

              return ((_arrowRef$current = arrowRef.current) == null ? void 0 : _arrowRef$current.clientWidth) || 0;
            }
          }
        }, {
          name: "arrow",
          enabled: Boolean(arrowRef.current),
          options: {
            element: arrowRef.current
          }
        }, {
          name: "updateState",
          phase: "write",
          enabled: true,

          fn(_ref) {
            var {
              state
            } = _ref;
            setPlacement(state.placement);
            setPopoverStyles(state.styles.popper);
            setArrowStyles(state.styles.arrow);
          }

        }, ...modifiersOverride]
      });
    }

    return () => {
      if (popper.current) {
        popper.current.destroy();
        popper.current = null;
      }
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [originalPlacement, fixed, forceUpdate, flip, offset, preventOverflow, eventsEnabled]);
  useSafeLayoutEffect(() => {
    var id = requestAnimationFrame(() => {
      if (forceUpdate) {
        var _popper$current;

        (_popper$current = popper.current) == null ? void 0 : _popper$current.forceUpdate();
      }
    });
    return () => {
      cancelAnimationFrame(id);
    };
  }, [forceUpdate]);

  var computedArrowStyles = _extends({}, arrowStyles, getArrowStyles(placement, arrowSize, arrowShadowColor));

  return {
    popperInstance: popper.current,
    reference: {
      ref: referenceRef
    },
    popper: {
      ref: popoverRef,
      style: _extends({}, popoverStyles, {
        transformOrigin: toTransformOrigin(placement)
      })
    },
    arrow: {
      ref: arrowRef,
      style: computedArrowStyles
    },
    update,
    placement,
    place
  };
}
//# sourceMappingURL=use-popper.js.map