function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { objectKeys } from "@chakra-ui/utils";
import * as React from "react";
import { Toast } from "./toast";
import { findToast, getToastPosition } from "./toast.utils";

/**
 * Manages the creation, and removal of toasts
 * across all corners ("top", "bottom", etc.)
 */
export class ToastManager extends React.Component {
  /**
   * Static id counter to create unique ids
   * for each toast
   */

  /**
   * State to track all the toast across all positions
   */
  constructor(props) {
    super(props);

    _defineProperty(this, "state", {
      top: [],
      "top-left": [],
      "top-right": [],
      "bottom-left": [],
      bottom: [],
      "bottom-right": []
    });

    _defineProperty(this, "notify", (message, options) => {
      var toast = this.createToast(message, options);
      var {
        position,
        id
      } = toast;
      this.setState(prevToasts => {
        /**
         * - If the toast is positioned at the top edges, the
         * recent toast stacks on top of the other toasts.
         *
         * - If the toast is positioned at the bottom edges, the recent
         * toast stacks below the other toasts.
         */
        var isTop = position.includes("top");
        return _extends({}, prevToasts, {
          [position]: isTop ? [toast, ...prevToasts[position]] : [...prevToasts[position], toast]
        });
      });
      return id;
    });

    _defineProperty(this, "updateToast", (id, options) => {
      this.setState(prevState => {
        var nextState = _extends({}, prevState);

        var {
          position,
          index
        } = findToast(nextState, id);

        if (position && index !== -1) {
          nextState[position][index] = _extends({}, nextState[position][index], options);
        }

        return nextState;
      });
    });

    _defineProperty(this, "closeAll", () => {
      objectKeys(this.state).forEach(position => {
        this.state[position].forEach(toast => {
          this.closeToast(toast.id);
        });
      });
    });

    _defineProperty(this, "createToast", (message, options) => {
      var _options$id, _options$position;

      var id = (_options$id = options.id) != null ? _options$id : ++ToastManager.counter;
      var position = (_options$position = options.position) != null ? _options$position : "top";
      return {
        id,
        message,
        position,
        duration: options.duration,
        onCloseComplete: options.onCloseComplete,
        onRequestRemove: () => this.removeToast(String(id), position),
        status: options.status
      };
    });

    _defineProperty(this, "closeToast", id => {
      this.setState(prevState => {
        var position = getToastPosition(prevState, id);
        if (!position) return prevState;
        return _extends({}, prevState, {
          [position]: prevState[position].map(toast => _extends({}, toast, {
            requestClose: toast.id == id
          }))
        });
      });
    });

    _defineProperty(this, "removeToast", (id, position) => {
      this.setState(prevState => {
        return _extends({}, prevState, {
          [position]: prevState[position].filter(toast => toast.id != id)
        });
      });
    });

    _defineProperty(this, "isVisible", id => {
      var {
        position
      } = findToast(this.state, id);
      return Boolean(position);
    });

    _defineProperty(this, "getStyle", position => {
      var style = {
        position: "fixed",
        zIndex: 5500,
        pointerEvents: "none"
      };

      if (position === "top" || position === "bottom") {
        style.margin = "0 auto";
        style.textAlign = "center";
      }

      if (position.includes("top")) {
        style.top = 0;
      }

      if (position.includes("bottom")) {
        style.bottom = 0;
      }

      if (!position.includes("left")) {
        style.right = 0;
      }

      if (!position.includes("right")) {
        style.left = 0;
      }

      return style;
    });

    var methods = {
      notify: this.notify,
      closeAll: this.closeAll,
      close: this.closeToast,
      update: this.updateToast,
      isActive: this.isVisible
    };
    props.notify(methods);
  }
  /**
   * Function to actually create a toast and add it
   * to state at the specified position
   */


  render() {
    return objectKeys(this.state).map(position => {
      var toasts = this.state[position];
      return /*#__PURE__*/React.createElement("span", {
        key: position,
        id: "chakra-toast-manager-" + position,
        style: this.getStyle(position)
      }, toasts.map(toast => /*#__PURE__*/React.createElement(Toast, _extends({
        key: toast.id
      }, toast))));
    });
  }

}

_defineProperty(ToastManager, "counter", 0);
//# sourceMappingURL=toast-manager.js.map