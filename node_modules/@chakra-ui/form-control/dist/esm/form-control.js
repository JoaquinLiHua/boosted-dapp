function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import { useBoolean, useId, useSafeLayoutEffect } from "@chakra-ui/hooks";
import { Icon } from "@chakra-ui/icon";
import { chakra, forwardRef, omitThemingProps, StylesProvider, useMultiStyleConfig, useStyleConfig, useStyles } from "@chakra-ui/system";
import { createContext, cx, __DEV__ } from "@chakra-ui/utils";
import * as React from "react";
import { useFormControlLabel } from "./use-form-control";
var [FormControlProvider, useFormControlContext] = createContext({
  strict: false,
  name: "FormControlContext"
});
export { useFormControlContext };

function useProvider(props) {
  var {
    id: idProp,
    isRequired,
    isInvalid,
    isDisabled,
    isLoading,
    isReadOnly
  } = props,
      htmlProps = _objectWithoutPropertiesLoose(props, ["id", "isRequired", "isInvalid", "isDisabled", "isLoading", "isReadOnly"]); // Generate all the required ids


  var uuid = useId();
  var id = idProp || "field-" + uuid;
  var labelId = id + "-label";
  var feedbackId = id + "-feedback";
  var helpTextId = id + "-helptext";
  /**
   * Track of when the `FormHelperText` has been rendered.
   * We use this to append it's id the the `aria-describedby` of the `input`
   */

  var [hasHelpText, setHasHelpText] = useBoolean(); // Let's keep track of when we focus the form element (e.g, `input`)

  var [isFocused, setFocus] = useBoolean();
  var context = {
    isRequired: !!isRequired,
    isInvalid: !!isInvalid,
    isLoading: !!isLoading,
    isReadOnly: !!isReadOnly,
    isDisabled: !!isDisabled,
    isFocused: !!isFocused,
    onFocus: setFocus.on,
    onBlur: setFocus.off,
    hasHelpText,
    setHasHelpText,
    id,
    labelId,
    feedbackId,
    helpTextId,
    htmlProps
  };
  return context;
}

/**
 * FormControl provides context such as
 * `isInvalid`, `isDisabled`, and `isRequired` to form elements.
 *
 * This is commonly used in form elements such as `input`,
 * `select`, `textarea`, etc.
 */
export var FormControl = /*#__PURE__*/forwardRef(function FormControl(props, ref) {
  var styles = useMultiStyleConfig("Form", props);
  var rest = omitThemingProps(props);

  var _useProvider = useProvider(rest),
      {
    htmlProps
  } = _useProvider,
      context = _objectWithoutPropertiesLoose(_useProvider, ["htmlProps"]);

  var _className = cx("chakra-form-control", props.className);

  return /*#__PURE__*/React.createElement(FormControlProvider, {
    value: context
  }, /*#__PURE__*/React.createElement(StylesProvider, {
    value: styles
  }, /*#__PURE__*/React.createElement(chakra.div, _extends({
    role: "group",
    ref: ref
  }, htmlProps, {
    className: _className,
    __css: {
      width: "100%",
      position: "relative"
    }
  }))));
});

if (__DEV__) {
  FormControl.displayName = "FormControl";
}

/**
 * Used to enhance the usability of form controls.
 *
 * It is used to inform users as to what information
 * is requested for a form field.
 *
 * ♿️ Accessibility: Every form field should have a form label.
 */
export var FormLabel = /*#__PURE__*/forwardRef(function FormLabel(props, ref) {
  var styles = useStyleConfig("FormLabel", props);

  var _omitThemingProps = omitThemingProps(props),
      {
    children
  } = _omitThemingProps,
      rest = _objectWithoutPropertiesLoose(_omitThemingProps, ["className", "children"]);

  var ownProps = useFormControlLabel(rest);
  var field = useFormControlContext();
  return /*#__PURE__*/React.createElement(chakra.label, _extends({
    ref: ref,
    className: cx("chakra-form__label", props.className),
    __css: _extends({
      display: "block",
      textAlign: "left"
    }, styles)
  }, ownProps), children, (field == null ? void 0 : field.isRequired) && /*#__PURE__*/React.createElement(RequiredIndicator, null));
});

if (__DEV__) {
  FormLabel.displayName = "FormLabel";
}

/**
 * Used to show a "required" text or an asterisks (*) to indicate that
 * a field is required.
 */
export var RequiredIndicator = /*#__PURE__*/forwardRef(function RequiredIndicator(props, ref) {
  var field = useFormControlContext();
  var styles = useStyles();
  if (!(field == null ? void 0 : field.isRequired)) return null;

  var _className = cx("chakra-form__required-indicator", props.className);

  return /*#__PURE__*/React.createElement(chakra.span, _extends({
    role: "presentation",
    "aria-hidden": true,
    ref: ref
  }, props, {
    __css: styles.requiredIndicator,
    className: _className,
    children: props.children || "*"
  }));
});

if (__DEV__) {
  RequiredIndicator.displayName = "RequiredIndicator";
}

/**
 * FormHelperText
 *
 * Assistive component that conveys additional guidance
 * about the field, such as how it will be used and what
 * types in values should be provided
 */
export var FormHelperText = /*#__PURE__*/forwardRef(function FormHelperText(props, ref) {
  var _props$id;

  var field = useFormControlContext();
  var styles = useStyles();
  /**
   * Notify the field context when the help text is rendered on
   * screen, so we can apply the correct `aria-describedby` to the field (e.g. input, textarea)
   */

  useSafeLayoutEffect(() => {
    field == null ? void 0 : field.setHasHelpText.on();
    return () => field == null ? void 0 : field.setHasHelpText.off();
  }, []);

  var _className = cx("chakra-form__helper-text", props.className);

  return /*#__PURE__*/React.createElement(chakra.div, _extends({
    ref: ref,
    __css: styles.helperText
  }, props, {
    className: _className,
    id: (_props$id = props.id) != null ? _props$id : field == null ? void 0 : field.helpTextId
  }));
});

if (__DEV__) {
  FormHelperText.displayName = "FormHelperText";
}

/**
 * Used to provide feedback about an invalid input,
 * and suggest clear instrctions on how to fix it.
 */
export var FormErrorMessage = /*#__PURE__*/forwardRef(function FormErrorMessage(props, ref) {
  var _props$id2;

  var styles = useStyles();
  var field = useFormControlContext();
  if (!(field == null ? void 0 : field.isInvalid)) return null;

  var _className = cx("chakra-form__error-message", props.className);

  return /*#__PURE__*/React.createElement(chakra.div, _extends({
    "aria-live": "polite",
    ref: ref
  }, props, {
    __css: _extends({
      display: "flex",
      alignItems: "center"
    }, styles.errorText),
    className: _className,
    id: (_props$id2 = props.id) != null ? _props$id2 : field == null ? void 0 : field.feedbackId
  }));
});

if (__DEV__) {
  FormErrorMessage.displayName = "FormErrorMessage";
}
/**
 * Used as the visual indicator that a field is invalid or
 * a field has incorrect values.
 */


export var FormErrorIcon = /*#__PURE__*/forwardRef(function FormErrorIcon(props, ref) {
  var styles = useStyles();
  var field = useFormControlContext();
  if (!(field == null ? void 0 : field.isInvalid)) return null;

  var _className = cx("chakra-form__error-icon", props.className);

  return /*#__PURE__*/React.createElement(Icon, _extends({
    ref: ref,
    "aria-hidden": true
  }, props, {
    __css: styles.errorIcon,
    className: _className
  }), /*#__PURE__*/React.createElement("path", {
    fill: "currentColor",
    d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
  }));
});

if (__DEV__) {
  FormErrorIcon.displayName = "FormErrorIcon";
}
//# sourceMappingURL=form-control.js.map