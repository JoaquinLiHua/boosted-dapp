function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import { CloseButton } from "@chakra-ui/close-button";
import { chakra, omitThemingProps, StylesProvider, useMultiStyleConfig, useStyles, forwardRef } from "@chakra-ui/system";
import { createContext, cx, runIfFn, __DEV__ } from "@chakra-ui/utils";
import React, { Children, cloneElement, useEffect } from "react";
import { usePopover } from "./use-popover";
var [PopoverProvider, usePopoverContext] = createContext({
  name: "PopoverContext",
  errorMessage: "usePopoverContext: `context` is undefined. Seems you forgot to wrap all popover components within `<Popover />`"
});
export { usePopoverContext };

/**
 * Popover is used to bring attention to specific user interface elements,
 * typically to suggest an action or to guide users through a new experience.
 */
export var Popover = props => {
  var styles = useMultiStyleConfig("Popover", props);

  var _omitThemingProps = omitThemingProps(props),
      {
    children
  } = _omitThemingProps,
      rest = _objectWithoutPropertiesLoose(_omitThemingProps, ["children"]);

  var context = usePopover(rest);
  return /*#__PURE__*/React.createElement(PopoverProvider, {
    value: context
  }, /*#__PURE__*/React.createElement(StylesProvider, {
    value: styles
  }, runIfFn(children, {
    isOpen: context.isOpen,
    onClose: context.onClose
  })));
};

if (__DEV__) {
  Popover.displayName = "Popover";
}
/**
 * PopoverTrigger opens the popover's content. It must be an interactive element
 * such as `button` or `a`.
 */


export var PopoverTrigger = props => {
  // enforce a single child
  var child = Children.only(props.children);
  var {
    getTriggerProps
  } = usePopoverContext();
  return /*#__PURE__*/cloneElement(child, getTriggerProps(child.props, child.ref));
};

if (__DEV__) {
  PopoverTrigger.displayName = "PopoverTrigger";
}

/**
 * PopoverContent includes all accessibility
 * requirements for a popover
 */
export var PopoverContent = /*#__PURE__*/forwardRef(function PopoverContent(props, ref) {
  var {
    getPopoverProps
  } = usePopoverContext();
  var popoverProps = getPopoverProps(props, ref);
  var styles = useStyles();

  var contentStyles = _extends({
    position: "relative",
    display: "flex",
    flexDirection: "column"
  }, styles.content);

  return /*#__PURE__*/React.createElement(chakra.section, _extends({
    className: cx("chakra-popover__content")
  }, popoverProps, {
    __css: contentStyles
  }));
});

if (__DEV__) {
  PopoverContent.displayName = "PopoverContent";
}

/**
 * PopoverHeader is the accessible header or label
 * for the popover's content and it's first announced by screenreaders.
 */
export var PopoverHeader = /*#__PURE__*/forwardRef(function PopoverHeader(props, ref) {
  var {
    headerId,
    setHasHeader
  } = usePopoverContext();
  useEffect(() => {
    setHasHeader.on();
    return () => setHasHeader.off();
  }, [setHasHeader]);
  var styles = useStyles();
  return /*#__PURE__*/React.createElement(chakra.header, _extends({}, props, {
    className: cx("chakra-popover__header", props.className),
    id: headerId,
    ref: ref,
    __css: styles.header
  }));
});

if (__DEV__) {
  PopoverHeader.displayName = "PopoverHeader";
}

/**
 * PopoverBody is the main content area for the popover. Should contain
 * at least one interactive element.
 */
export var PopoverBody = /*#__PURE__*/forwardRef(function PopoverBody(props, ref) {
  var {
    bodyId,
    setHasBody
  } = usePopoverContext();
  useEffect(() => {
    setHasBody.on();
    return () => setHasBody.off();
  }, [setHasBody]);
  var styles = useStyles();
  return /*#__PURE__*/React.createElement(chakra.div, _extends({}, props, {
    className: cx("chakra-popover__body", props.className),
    id: bodyId,
    ref: ref,
    __css: styles.body
  }));
});

if (__DEV__) {
  PopoverBody.displayName = "PopoverBody";
}

export var PopoverFooter = props => {
  var styles = useStyles();
  return /*#__PURE__*/React.createElement(chakra.footer, _extends({}, props, {
    className: cx("chakra-popover__footer", props.className),
    __css: styles.footer
  }));
};

if (__DEV__) {
  PopoverFooter.displayName = "PopoverFooter";
}

export var PopoverCloseButton = props => {
  var {
    onClose
  } = usePopoverContext();
  return /*#__PURE__*/React.createElement(CloseButton, _extends({
    size: "sm",
    onClick: onClose,
    position: "absolute",
    borderRadius: "md",
    top: "0.25rem",
    right: "0.5rem",
    padding: "0.5rem"
  }, props));
};

if (__DEV__) {
  PopoverCloseButton.displayName = "PopoverCloseButton";
}

export var PopoverArrow = props => {
  var {
    getArrowProps
  } = usePopoverContext();
  var arrowProps = getArrowProps(props);
  var styles = useStyles();

  var arrowStyles = _extends({
    bg: "inherit"
  }, styles.arrow);

  return /*#__PURE__*/React.createElement(chakra.div, _extends({}, arrowProps, {
    className: cx("chakra-popover__arrow", props.className),
    __css: arrowStyles
  }));
};

if (__DEV__) {
  PopoverArrow.displayName = "PopoverArrow";
}
//# sourceMappingURL=popover.js.map