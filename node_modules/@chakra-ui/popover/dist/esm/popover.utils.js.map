{"version":3,"sources":["../../src/popover.utils.ts"],"names":["useUpdateEffect","useEventListener","focus","getFirstTabbableIn","isFocusable","useRef","useFocusOnHide","popoverRef","options","isFocusableRef","focusRef","autoFocus","visible","trigger","shouldFocus","onPointerDown","event","target","prevent","current","contains","useFocusOnShow","firstTabbable"],"mappings":"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","sourcesContent":["import { useUpdateEffect, useEventListener } from \"@chakra-ui/hooks\"\nimport { focus, getFirstTabbableIn, isFocusable } from \"@chakra-ui/utils\"\nimport { RefObject, useRef } from \"react\"\n\nexport interface UseFocusOnHideOptions {\n  focusRef: RefObject<HTMLElement>\n  autoFocus?: boolean\n  visible?: boolean\n  trigger?: \"hover\" | \"click\"\n}\n\n/**\n * Popover hook to manage the focus when the popover closes or hides.\n *\n * We either want to return focus back to the popover trigger or\n * let focus proceed normally if user moved to another interactive\n * element in the viewport.\n */\nexport function useFocusOnHide(\n  popoverRef: RefObject<HTMLElement>,\n  options: UseFocusOnHideOptions,\n) {\n  const isFocusableRef = useRef(false)\n  const { focusRef, autoFocus, visible, trigger } = options\n\n  const shouldFocus = autoFocus && !visible && trigger === \"click\"\n\n  const onPointerDown = (event: MouseEvent) => {\n    if (!options.visible) return\n    const target = event.target as HTMLElement\n\n    const prevent =\n      isFocusable(target) &&\n      target !== focusRef.current &&\n      !(popoverRef.current as HTMLElement).contains(target)\n\n    if (prevent) {\n      isFocusableRef.current = true\n    }\n  }\n\n  useEventListener(\"mousedown\", onPointerDown)\n  useEventListener(\"touchstart\", onPointerDown)\n\n  useUpdateEffect(() => {\n    return () => {\n      if (!visible) {\n        isFocusableRef.current = false\n      }\n    }\n  }, [visible])\n\n  /**\n   * Using updateEffect here to allow effect to run only when\n   * `options.visible` changes, not on mount\n   */\n  useUpdateEffect(() => {\n    if (!shouldFocus || !popoverRef.current) return\n\n    if (isFocusableRef.current) return\n\n    if (focusRef.current) {\n      focus(focusRef.current)\n    }\n  }, [autoFocus, focusRef, visible, popoverRef, shouldFocus])\n}\n\ninterface UseFocusOnShowOptions {\n  autoFocus?: boolean\n  visible?: boolean\n  focusRef?: RefObject<HTMLElement>\n  trigger?: \"hover\" | \"click\"\n}\n\n/**\n * Popover hook to manage the focus when the popover opens.\n *\n * We either want to focus the popover content itself since it\n * has `tabIndex = -1`, or focus the first interactive element\n * within the popover content.\n */\nexport function useFocusOnShow(\n  popoverRef: RefObject<HTMLElement>,\n  options: UseFocusOnShowOptions,\n) {\n  const { visible, autoFocus, focusRef, trigger } = options\n\n  /**\n   * Using updateEffect here to allow effect to run only when\n   * `options.visible` changes, not on mount\n   */\n  useUpdateEffect(() => {\n    if (trigger === \"hover\") return\n\n    // if `autoFocus` is false, move focus to the `PopoverContent`\n    if (!autoFocus && popoverRef.current) {\n      focus(popoverRef.current)\n      return\n    }\n\n    const shouldFocus = visible && autoFocus\n\n    if (!shouldFocus) return\n\n    if (focusRef?.current) {\n      focus(focusRef.current)\n      return\n    }\n\n    if (popoverRef.current) {\n      const firstTabbable = getFirstTabbableIn(popoverRef.current, true)\n      focus(firstTabbable ?? popoverRef.current)\n    }\n  }, [visible, autoFocus, popoverRef, focusRef])\n}\n"],"file":"popover.utils.js"}